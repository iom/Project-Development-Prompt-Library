# IOM Prompt Library – Replit Build Brief (for Replit developer)

> Goal: Build a production-ready, lightweight web app to browse, search, submit, and administer a library of prompts for project development at IOM. Admins can manage categories, prompts, and submissions via a secure backend.

---

## 1) High-level overview

* **Audience**

  * **Contributors (Users):** browse/search prompts; submit new prompts for review.
  * **Admins:** approve/reject submissions; create/edit/delete categories and prompts; manage metadata.
* **Key screens**

  * **Public Library:** Category filter ➜ list of prompts with search, sort, pagination.
  * **Prompt Detail:** title, body, category(+optional subcategory), AI platform, instructions, tags; copy button.
  * **Submit Prompt:** form with fields; success confirmation.
  * **Admin Dashboard (auth’d):** review queue; edit prompts; categories manager; audit log.
* **Non-goals** (v1): version history UI, granular org-level RBAC beyond Admin/User, SSO; rich text formatting beyond Markdown.

---

## 2) Tech stack (Replit-friendly)

* **Backend:** Python **FastAPI**
* **DB:** SQLite (bundled, simple for Replit); optional upgrade path to Postgres.
* **ORM:** SQLModel (or SQLAlchemy 2.x). Use Alembic for migrations.
* **Auth:** Session cookies with fastapi-users (or simple OAuth later). For v1, email+password admin users.
* **Frontend:** FastAPI + Jinja2 templates **or** small **React (Vite)** client consuming JSON API. Choose based on speed:

  * If time-constrained: **Jinja2** with HTMX for interactivity.
  * If SPA preferred: **Vite React** + Tailwind; call REST API.
* **Styling:** Tailwind CSS (if SPA) or Pico.css (if server-rendered) for minimal, clean UI.
* **Deployment:** Replit always-on web server; `.replit` + `poetry` or `pip` requirements.

---

## 3) Data model

```mermaid
erDiagram
    User ||--o{ Prompt : created_by
    User ||--o{ PromptSubmission : submitted_by
    Category ||--o{ Prompt : contains

    User {
      int id PK
      str email UNIQUE
      str password_hash
      str role  // 'admin' or 'user'
      datetime created_at
      datetime updated_at
    }

    Category {
      int id PK
      str name UNIQUE
      str slug UNIQUE
      str description NULL
      int parent_id NULL // for optional subcategory hierarchy
      datetime created_at
      datetime updated_at
    }

    Prompt {
      int id PK
      str title
      text body         // the prompt text
      int category_id FK
      int subcategory_id NULL FK // optional: self-referential to Category or a separate table
      str ai_platform NULL // e.g. 'ChatGPT', 'Claude', 'Midjourney'
      text instructions NULL // usage tips/notes
      json tags [] NULL
      str status // 'draft' | 'published' | 'archived'
      int created_by FK User
      datetime created_at
      datetime updated_at
    }

    PromptSubmission {
      int id PK
      str title
      text body
      int category_id FK
      int subcategory_id NULL FK
      str ai_platform NULL
      text instructions NULL
      json tags [] NULL
      str status // 'pending' | 'approved' | 'rejected'
      int submitted_by FK User NULL // allow anonymous if not logged in
      text reviewer_notes NULL
      datetime created_at
      datetime reviewed_at NULL
      int approved_prompt_id NULL FK Prompt // link upon approval
    }

    AuditLog {
      int id PK
      int actor_user_id FK User
      str action // CREATE_PROMPT, UPDATE_PROMPT, APPROVE_SUBMISSION, etc.
      json payload
      datetime created_at
    }
```

**Notes**

* **Subcategories:** implement with hierarchical `Category` (parent\_id). If there’s no explicit subcategory in the CSV, parent categories are enough, but the structure supports future nesting.
* **CSV columns mapped:** Title → `Prompt.title`, Prompt → `Prompt.body`, Category → `Category.name`, AI Platform → `Prompt.ai_platform`, Instructions → `Prompt.instructions`.

---

## 4) API (REST) – minimal v1

Base URL: `/api`

### Auth

* `POST /api/auth/login` – email + password; sets session cookie.
* `POST /api/auth/logout`

### Library (public)

* `GET /api/prompts?query=&category=&subcategory=&platform=&page=&page_size=` → list (title, excerpt, category, tags). Server-side pagination.
* `GET /api/prompts/{id}` → full prompt detail.
* `GET /api/categories` → flat list with parent/child nesting.

### Submissions (public)

* `POST /api/submissions` → create prompt submission. Body: {title, body, category\_id, subcategory\_id?, ai\_platform?, instructions?, tags?}

### Admin (auth: admin)

* `GET /api/admin/submissions?status=pending` → review queue.
* `PATCH /api/admin/submissions/{id}` → `status=approved|rejected`, `reviewer_notes`, if approved → create `Prompt` and link `approved_prompt_id`.
* `POST /api/admin/prompts` → create.
* `PATCH /api/admin/prompts/{id}` → edit fields incl. move categories, rename, publish/archive.
* `DELETE /api/admin/prompts/{id}` → soft delete (archive).
* `POST /api/admin/categories` → create category or subcategory (parent\_id optional).
* `PATCH /api/admin/categories/{id}` → rename, reparent, set description.
* `GET /api/admin/audit-logs` → paginated logs.

**Responses**

* Use JSON, camelCase on the wire, snake\_case in DB.
* Validate with Pydantic models; return 422 on invalid.

---

## 5) UX requirements

* **Library page**

  * Left sidebar: **Category tree** (expandable); clicking filters results.
  * Top search bar: keyword search on title/body/instructions.
  * Filters: platform, status (published only for public), tags.
  * Cards list: title, category path (Category › Subcategory), first 200 chars of body, copy button.
  * Infinite scroll or numbered pagination.
* **Prompt detail**

  * Full text with “Copy to clipboard”.
  * Metadata: category path, platform, instructions, tags.
* **Submit prompt**

  * Required: title, body, category.
  * Optional: subcategory, ai\_platform, instructions, tags.
  * CSRF token; rate limit by IP.
* **Admin dashboard**

  * Tabs: Review Queue, Prompts, Categories, Audit.
  * Review: show submission side-by-side; Approve ➜ modal to tweak fields before saving.
  * Prompts list: bulk publish/archive; quick edit.
  * Categories: create/rename/drag to reparent (optional v1: simple create/rename only).

---

## 6) Import & seed from CSV (already provided)

* The owner has provided a CSV. We’ve generated a **normalized seed JSON** you can load at bootstrap time.

  * File path: `/mnt/data/prompts_seed.json`
* **Import logic**

  1. Ensure each distinct `Category.name` exists; generate `slug` (kebab-case). Parent is `NULL` for v1 unless an inferred hierarchy is provided.
  2. Create `Prompt` rows with `status='published'`, mapping CSV fields.
  3. Avoid duplicates by `title` + `category_id`.

**Example seed script (Python, pseudo)**

```python
from sqlmodel import Session, select
from models import Category, Prompt
import json, slugify

with open('prompts_seed.json', 'r', encoding='utf-8') as f:
    data = json.load(f)

for item in data:
    cat = session.exec(select(Category).where(Category.name==item['category'])).first()
    if not cat:
        cat = Category(name=item['category'], slug=slugify(item['category']))
        session.add(cat); session.commit(); session.refresh(cat)
    p = Prompt(title=item['title'], body=item['body'], category_id=cat.id,
               ai_platform=item.get('ai_platform'), instructions=item.get('instructions'),
               status=item.get('status','published'))
    session.add(p)
session.commit()
```

---

## 7) File layout (FastAPI + server-rendered option)

```
replit.toml             # or .replit
requirements.txt
app/
  main.py               # FastAPI app & routes
  deps.py               # db/session wiring
  models.py             # SQLModel definitions
  schemas.py            # Pydantic models
  routers/
    public.py           # prompts, categories
    submissions.py      # public submissions
    admin.py            # admin-only endpoints
    auth.py             # login/logout
  services/
    prompts.py          # query helpers
    categories.py
    submissions.py
  templates/
    base.html
    library.html
    prompt_detail.html
    submit.html
    admin/
      dashboard.html
      review_queue.html
      prompts.html
      categories.html
  static/
    css/
    js/
seed/
  prompts_seed.json     # copy of /mnt/data/prompts_seed.json
  import_seed.py
```

---

## 8) Example code snippets

**`models.py`** (SQLModel)

```python
from typing import Optional, List
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime

class User(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    email: str = Field(index=True, unique=True)
    password_hash: str
    role: str = Field(default="user")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Category(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str = Field(index=True, unique=True)
    slug: str = Field(index=True, unique=True)
    description: Optional[str] = None
    parent_id: Optional[int] = Field(default=None, foreign_key="category.id")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Prompt(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str
    body: str
    category_id: int = Field(foreign_key="category.id")
    subcategory_id: Optional[int] = Field(default=None, foreign_key="category.id")
    ai_platform: Optional[str] = None
    instructions: Optional[str] = None
    tags: Optional[str] = None  # JSON string; keep simple in v1
    status: str = Field(default="published")
    created_by: Optional[int] = Field(default=None, foreign_key="user.id")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class PromptSubmission(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str
    body: str
    category_id: int = Field(foreign_key="category.id")
    subcategory_id: Optional[int] = Field(default=None, foreign_key="category.id")
    ai_platform: Optional[str] = None
    instructions: Optional[str] = None
    tags: Optional[str] = None
    status: str = Field(default="pending")
    submitted_by: Optional[int] = Field(default=None, foreign_key="user.id")
    reviewer_notes: Optional[str] = None
    approved_prompt_id: Optional[int] = Field(default=None, foreign_key="prompt.id")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    reviewed_at: Optional[datetime] = None
```

**`routers/public.py`** (excerpt)

```python
from fastapi import APIRouter, Depends, Query
from sqlmodel import select
from app.deps import SessionDep
from app.models import Prompt, Category

router = APIRouter(prefix="/api", tags=["public"])

@router.get("/prompts")
def list_prompts(session: SessionDep, query: str = "", category: int | None = None,
                 platform: str | None = None, page: int = 1, page_size: int = 20):
    stmt = select(Prompt).where(Prompt.status=="published")
    if query:
        like = f"%{query}%"
        stmt = stmt.where((Prompt.title.ilike(like)) | (Prompt.body.ilike(like)))
    if category:
        stmt = stmt.where((Prompt.category_id==category) | (Prompt.subcategory_id==category))
    if platform:
        stmt = stmt.where(Prompt.ai_platform==platform)
    total = session.exec(stmt).all()
    start = (page-1)*page_size
    items = total[start:start+page_size]
    return {"items": items, "total": len(total), "page": page, "pageSize": page_size}
```

**`routers/admin.py`** (excerpt)

```python
from fastapi import APIRouter, Depends, HTTPException
from app.deps import SessionDep, admin_required
from app.models import PromptSubmission, Prompt
from datetime import datetime

router = APIRouter(prefix="/api/admin", tags=["admin"])

@router.get("/submissions")
def list_submissions(session: SessionDep, status: str = "pending"):
    return session.exec(select(PromptSubmission).where(PromptSubmission.status==status)).all()

@router.patch("/submissions/{sid}")
def review_submission(sid: int, payload: dict, session: SessionDep, user=Depends(admin_required)):
    sub = session.get(PromptSubmission, sid)
    if not sub:
        raise HTTPException(404, "Not found")
    decision = payload.get("status")
    if decision not in ["approved", "rejected"]:
        raise HTTPException(400, "Invalid status")
    sub.status = decision
    sub.reviewer_notes = payload.get("reviewer_notes")
    sub.reviewed_at = datetime.utcnow()
    if decision == "approved":
        prompt = Prompt(title=sub.title, body=sub.body, category_id=sub.category_id,
                        subcategory_id=sub.subcategory_id, ai_platform=sub.ai_platform,
                        instructions=sub.instructions, status="published")
        session.add(prompt); session.flush()
        sub.approved_prompt_id = prompt.id
    session.commit()
    return {"ok": True}
```

---

## 9) Admin & security

* **Roles:** `admin`, `user` (default). Only admins can access admin endpoints.
* **CSRF:** enable on form posts (if SSR). For SPA, use same-site cookies + CSRF token.
* **Rate limiting:** submissions endpoint (e.g., 5/min per IP) to reduce spam.
* **Audit logs:** append an entry for every admin action.
* **CORS:** lock to site origin.

---

## 10) Search & performance

* SQLite with LIKE queries is fine for v1 (dataset is small). If growth demands, add FTS5 virtual table for full-text search.
* Pagination: server-side only; default 20 per page.

---

## 11) Testing & QA

* Unit tests for services and routers (pytest).
* Minimal e2e: submit → approve → visible in library.
* Seed script test to ensure CSV → DB import works idempotently.

---

## 12) Hand-off checklist

* ✅ Working `/api` as spec’d
* ✅ Public library UI with category filter + search
* ✅ Submit Prompt form with validation & rate-limit
* ✅ Admin dashboard: review queue, prompts CRUD, categories CRUD
* ✅ Seeded database from `/seed/prompts_seed.json`
* ✅ README with setup steps (below)

---

## 13) Setup steps (Replit)

1. Create a Python Repl. Add `requirements.txt`:

   ```
   fastapi
   uvicorn
   sqlmodel
   sqlalchemy
   aiosqlite
   jinja2
   python-multipart
   passlib[bcrypt]
   itsdangerous
   htmx==1.9.10  # if SSR/HTMX chosen
   ```
2. `uvicorn app.main:app --host 0.0.0.0 --port 8000` (configure in `.replit`).
3. Initialize DB and run alembic migrations (or `SQLModel.metadata.create_all`).
4. Copy seed file to project `seed/prompts_seed.json` and run `python seed/import_seed.py`.
5. Create first admin user manually (script) and log in.

---

## 14) Nice-to-haves (post-v1)

* Prompt versioning & changelog.
* Export to CSV/JSON.
* Tag manager with autocomplete.
* Bulk import via CSV upload in admin.
* FTS search with ranking.
* User favorites & collections.

---

**Questions left for later (not blocking v1):**

* Do we want SSO (e.g., Google Workspace) for admins?
* Should submissions allow anonymous or require login?
* Any restricted categories that require internal visibility only?
